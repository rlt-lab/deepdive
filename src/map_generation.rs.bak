use std::collections::HashSet;
use rand::Rng;
use crate::components::TileType;
use crate::biome::BiomeType;

#[derive(Clone, Debug)]
pub struct MapGenParams {
    pub algorithm: MapGenAlgorithm,
    pub steps: u32,
    pub walkers: u32,
    pub room_min_size: u32,
    pub room_max_size: u32,
    pub max_rooms: u32,
    pub corridor_width: u32,
    pub connectivity_chance: f32,
}

#[derive(Clone, Debug)]
pub enum MapGenAlgorithm {
    DrunkardWalk,
    PrisonBlocks,
    BSPDungeon,
    CellularAutomata,
    Maze,
    Voronoi,
}

impl MapGenParams {
    pub fn for_biome(biome: BiomeType, level: u32) -> Self {
        match biome {
            BiomeType::Caverns => Self::caverns_params(level),
            BiomeType::Underglade => Self::underglade_params(level),
            BiomeType::FungalDeep => Self::fungal_deep_params(level),
            BiomeType::CinderGaol => Self::cinder_gaol_params(level),
            BiomeType::AbyssalHold => Self::abyssal_hold_params(level),
            BiomeType::NetherGrange => Self::nether_grange_params(level),
            BiomeType::ChthronicCrypts => Self::chthonic_crypts_params(level),
            BiomeType::HypogealKnot => Self::hypogeal_knot_params(level),
            BiomeType::StygianPool => Self::stygian_pool_params(level),
        }
    }

    fn caverns_params(level: u32) -> Self {
        Self {
            algorithm: MapGenAlgorithm::DrunkardWalk,
            steps: 2500 + (level * 50),
            walkers: 4 + (level / 3),
            room_min_size: 4,
            room_max_size: 8,
            max_rooms: 8,
            corridor_width: 1,
            connectivity_chance: 0.15,
        }
    }

    fn underglade_params(level: u32) -> Self {
        Self {
            algorithm: MapGenAlgorithm::Voronoi,
            steps: 0, // Not used for Voronoi
            walkers: 8 + (level / 3), // Number of Voronoi sites/clusters
            room_min_size: 4, // Minimum clearing size
            room_max_size: 12, // Maximum clearing size
            max_rooms: 6 + (level / 4), // Number of forest clearings
            corridor_width: 2, // Path width through forest
            connectivity_chance: 0.25, // Path connectivity between clearings
        }
    }

    fn fungal_deep_params(level: u32) -> Self {
        Self {
            algorithm: MapGenAlgorithm::CellularAutomata,
            steps: 3000 + (level * 60),
            walkers: 5 + (level / 2),
            room_min_size: 5,
            room_max_size: 12,
            max_rooms: 4,
            corridor_width: 1,
            connectivity_chance: 0.1,
        }
    }

    fn cinder_gaol_params(level: u32) -> Self {
        Self {
            algorithm: MapGenAlgorithm::BSPDungeon,
            steps: 0, // Not used for BSP
            walkers: 0, // Not used for BSP
            room_min_size: 6, // Prison cells and chambers
            room_max_size: 14, // Large fortress rooms
            max_rooms: 8 + (level / 4), // More rooms with depth
            corridor_width: 2, // Structured fortress corridors
            connectivity_chance: 0.3, // Moderate connectivity for fortress layout
        }
    }

    fn abyssal_hold_params(level: u32) -> Self {
        Self {
            algorithm: MapGenAlgorithm::BSPDungeon,
            steps: 1800 + (level * 30),
            walkers: 2 + (level / 6),
            room_min_size: 6,
            room_max_size: 15,
            max_rooms: 12,
            corridor_width: 2,
            connectivity_chance: 0.25,
        }
    }

    fn nether_grange_params(level: u32) -> Self {
        Self {
            algorithm: MapGenAlgorithm::Voronoi,
            steps: 2800 + (level * 55),
            walkers: 6 + (level / 2),
            room_min_size: 4,
            room_max_size: 10,
            max_rooms: 8,
            corridor_width: 2,
            connectivity_chance: 0.3,
        }
    }

    fn chthonic_crypts_params(level: u32) -> Self {
        Self {
            algorithm: MapGenAlgorithm::BSPDungeon,
            steps: 1500 + (level * 25),
            walkers: 1 + (level / 8),
            room_min_size: 4,
            room_max_size: 8,
            max_rooms: 15,
            corridor_width: 1,
            connectivity_chance: 0.1,
        }
    }

    fn hypogeal_knot_params(level: u32) -> Self {
        Self {
            algorithm: MapGenAlgorithm::Maze,
            steps: 3500 + (level * 70),
            walkers: 8 + (level / 2),
            room_min_size: 2,
            room_max_size: 4,
            max_rooms: 25,
            corridor_width: 1,
            connectivity_chance: 0.4, // High connectivity for maze
        }
    }

    fn stygian_pool_params(level: u32) -> Self {
        Self {
            algorithm: MapGenAlgorithm::CellularAutomata,
            steps: 2000 + (level * 45),
            walkers: 3 + (level / 5),
            room_min_size: 8,
            room_max_size: 20,
            max_rooms: 3,
            corridor_width: 3,
            connectivity_chance: 0.35,
        }
    }
}

pub trait MapGenerator {
    fn generate(&mut self, width: u32, height: u32, params: &MapGenParams) -> Vec<TileType>;
}

// Helper function to convert 2D Vec to flat Vec
fn flatten_tiles(tiles_2d: Vec<Vec<TileType>>, width: u32, height: u32) -> Vec<TileType> {
    let mut flat = vec![TileType::Wall; (width * height) as usize];
    for y in 0..height {
        for x in 0..width {
            flat[(y * width + x) as usize] = tiles_2d[y as usize][x as usize];
        }
    }
    flat
}

pub struct DrunkardWalkGenerator;

impl MapGenerator for DrunkardWalkGenerator {
    fn generate(&mut self, width: u32, height: u32, params: &MapGenParams) -> Vec<TileType> {
        let mut tiles = vec![vec![TileType::Wall; width as usize]; height as usize];
        let mut rng = rand::rng();
        let mut carved_positions = HashSet::new();

        // Multiple walkers for more interesting caves
        for _ in 0..params.walkers {
            let mut x = width / 2;
            let mut y = height / 2;

            // Carve the starting position
            tiles[y as usize][x as usize] = TileType::Floor;
            carved_positions.insert((x, y));

            // Perform drunkard walk
            for _ in 0..params.steps {
                let direction = rng.random_range(0..4);

                let (new_x, new_y) = match direction {
                    0 if y > 0 => (x, y - 1),
                    1 if x < width - 1 => (x + 1, y),
                    2 if y < height - 1 => (x, y + 1),
                    3 if x > 0 => (x - 1, y),
                    _ => (x, y),
                };

                // Check if within ellipse boundary
                if is_within_ellipse(new_x, new_y, width, height) {
                    x = new_x;
                    y = new_y;

                    tiles[y as usize][x as usize] = TileType::Floor;
                    carved_positions.insert((x, y));
                }
            }
        }

        flatten_tiles(tiles, width, height)
    }
}

pub struct PrisonBlocksGenerator;

impl MapGenerator for PrisonBlocksGenerator {
    fn generate(&mut self, width: u32, height: u32, params: &MapGenParams) -> Vec<TileType> {
        let mut tiles = vec![vec![TileType::Wall; width as usize]; height as usize];
        let mut rng = rand::rng();
        let mut rooms = Vec::new();
        let mut corridors = Vec::new();
        
        // Phase 1: Generate prominent main chambers
        self.generate_main_chambers(&mut tiles, &mut rooms, width, height, params, &mut rng);
        
        // Phase 2: Create elaborate tunnel systems
        self.create_tunnel_network(&mut tiles, &mut corridors, &rooms, width, height, params, &mut rng);
        
        // Phase 3: Add additional connectivity loops to prevent parallel walls
        self.add_connectivity_loops(&mut tiles, &rooms, &corridors, width, height, params, &mut rng);
        
        // Phase 4: Generate integrated prison cell blocks
        self.generate_prison_cells(&mut tiles, &rooms, &corridors, width, height, params, &mut rng);
        
        // Phase 5: Post-processing to eliminate problematic parallel walls
        self.eliminate_parallel_walls(&mut tiles, width, height, &mut rng);
        
        tiles
    }
}

impl PrisonBlocksGenerator {
    fn generate_main_chambers(&self, tiles: &mut Vec<Vec<TileType>>, rooms: &mut Vec<Room>, 
                             width: u32, height: u32, params: &MapGenParams, rng: &mut impl Rng) {
        for _ in 0..params.max_rooms {
            let attempts = 100;
            for _ in 0..attempts {
                // Create larger, more varied room shapes
                let base_width = rng.random_range(params.room_min_size..=params.room_max_size);
                let base_height = rng.random_range(params.room_min_size..=params.room_max_size);
                
                // Add some variation to create more interesting room shapes
                let room_width = base_width + rng.random_range(0..=3);
                let room_height = base_height + rng.random_range(0..=3);
                
                let x = rng.random_range(3..width.saturating_sub(room_width + 3));
                let y = rng.random_range(3..height.saturating_sub(room_height + 3));
                
                let center_x = x + room_width / 2;
                let center_y = y + room_height / 2;
                
                if is_within_ellipse(center_x, center_y, width, height) {
                    let new_room = Room { x, y, width: room_width, height: room_height };
                    
                    let mut overlaps = false;
                    for existing_room in rooms.iter() {
                        if rooms_overlap(&new_room, existing_room, 5) {
                            overlaps = true;
                            break;
                        }
                    }
                    
                    if !overlaps {
                        // Create more interesting room shapes (not just rectangles)
                        self.carve_chamber(tiles, &new_room, width, height, rng);
                        rooms.push(new_room);
                        break;
                    }
                }
            }
        }
    }
    
    fn carve_chamber(&self, tiles: &mut Vec<Vec<TileType>>, room: &Room, 
                    width: u32, height: u32, rng: &mut impl Rng) {
        let shape_type = rng.random_range(0..4);
        
        match shape_type {
            0 => {
                // Standard rectangular room
                for ry in room.y..room.y + room.height {
                    for rx in room.x..room.x + room.width {
                        if rx < width && ry < height {
                            tiles[ry as usize][rx as usize] = TileType::Floor;
                        }
                    }
                }
            },
            1 => {
                // Rounded corners
                let center_x = room.x + room.width / 2;
                let center_y = room.y + room.height / 2;
                let radius_x = room.width as f32 / 2.0;
                let radius_y = room.height as f32 / 2.0;
                
                for ry in room.y..room.y + room.height {
                    for rx in room.x..room.x + room.width {
                        if rx < width && ry < height {
                            let dx = (rx as f32 - center_x as f32) / radius_x;
                            let dy = (ry as f32 - center_y as f32) / radius_y;
                            
                            // Create elliptical room with some margin
                            if dx * dx + dy * dy <= 1.2 {
                                tiles[ry as usize][rx as usize] = TileType::Floor;
                            }
                        }
                    }
                }
            },
            2 => {
                // L-shaped chamber
                let split_x = room.x + room.width / 2;
                let split_y = room.y + room.height / 2;
                
                // Top-left and bottom-right sections
                for ry in room.y..split_y {
                    for rx in room.x..room.x + room.width {
                        if rx < width && ry < height {
                            tiles[ry as usize][rx as usize] = TileType::Floor;
                        }
                    }
                }
                
                for ry in split_y..room.y + room.height {
                    for rx in split_x..room.x + room.width {
                        if rx < width && ry < height {
                            tiles[ry as usize][rx as usize] = TileType::Floor;
                        }
                    }
                }
            },
            _ => {
                // Cross-shaped chamber
                let center_x = room.x + room.width / 2;
                let center_y = room.y + room.height / 2;
                let arm_width = room.width / 3;
                let arm_height = room.height / 3;
                
                // Horizontal arm
                for ry in center_y.saturating_sub(arm_height/2)..center_y + arm_height/2 {
                    for rx in room.x..room.x + room.width {
                        if rx < width && ry < height {
                            tiles[ry as usize][rx as usize] = TileType::Floor;
                        }
                    }
                }
                
                // Vertical arm
                for ry in room.y..room.y + room.height {
                    for rx in center_x.saturating_sub(arm_width/2)..center_x + arm_width/2 {
                        if rx < width && ry < height {
                            tiles[ry as usize][rx as usize] = TileType::Floor;
                        }
                    }
                }
            }
        }
    }
    
    fn create_tunnel_network(&self, tiles: &mut Vec<Vec<TileType>>, corridors: &mut Vec<Corridor>,
                           rooms: &Vec<Room>, width: u32, height: u32, params: &MapGenParams, rng: &mut impl Rng) {
        if rooms.len() < 2 { return; }
        
        // Create main spine corridors (different patterns)
        match rng.random_range(0..3) {
            0 => self.create_hub_and_spoke(tiles, corridors, rooms, width, height, params, rng),
            1 => self.create_linear_spine(tiles, corridors, rooms, width, height, params, rng),
            _ => self.create_ring_network(tiles, corridors, rooms, width, height, params, rng),
        }
    }
    
    fn create_hub_and_spoke(&self, tiles: &mut Vec<Vec<TileType>>, corridors: &mut Vec<Corridor>,
                          rooms: &Vec<Room>, width: u32, height: u32, params: &MapGenParams, rng: &mut impl Rng) {
        // Find central hub area
        let center_x = width / 2;
        let center_y = height / 2;
        let hub_size = 6;
        
        // Create central hub
        for ry in center_y.saturating_sub(hub_size/2)..center_y + hub_size/2 {
            for rx in center_x.saturating_sub(hub_size/2)..center_x + hub_size/2 {
                if rx < width && ry < height && is_within_ellipse(rx, ry, width, height) {
                    tiles[ry as usize][rx as usize] = TileType::Floor;
                }
            }
        }
        
        // Connect all rooms to hub with varying corridor styles
        for room in rooms {
            let room_center = (room.x + room.width / 2, room.y + room.height / 2);
            self.create_elaborate_corridor(tiles, corridors, (center_x, center_y), room_center, 
                                         width, height, params.corridor_width, rng);
        }
    }
    
    fn create_linear_spine(&self, tiles: &mut Vec<Vec<TileType>>, corridors: &mut Vec<Corridor>,
                         rooms: &Vec<Room>, width: u32, height: u32, params: &MapGenParams, rng: &mut impl Rng) {
        // Sort rooms by position to create linear connections
        let mut sorted_rooms = rooms.clone();
        sorted_rooms.sort_by_key(|r| r.x + r.y);
        
        // Create main spine
        for i in 0..sorted_rooms.len() - 1 {
            let room1_center = (sorted_rooms[i].x + sorted_rooms[i].width / 2, 
                              sorted_rooms[i].y + sorted_rooms[i].height / 2);
            let room2_center = (sorted_rooms[i + 1].x + sorted_rooms[i + 1].width / 2, 
                              sorted_rooms[i + 1].y + sorted_rooms[i + 1].height / 2);
            
            self.create_elaborate_corridor(tiles, corridors, room1_center, room2_center, 
                                         width, height, params.corridor_width, rng);
        }
        
        // Add some branch connections
        for i in 0..sorted_rooms.len() - 2 {
            if rng.random::<f32>() < 0.4 {
                let room1_center = (sorted_rooms[i].x + sorted_rooms[i].width / 2, 
                                  sorted_rooms[i].y + sorted_rooms[i].height / 2);
                let room2_center = (sorted_rooms[i + 2].x + sorted_rooms[i + 2].width / 2, 
                                  sorted_rooms[i + 2].y + sorted_rooms[i + 2].height / 2);
                
                self.create_elaborate_corridor(tiles, corridors, room1_center, room2_center, 
                                             width, height, params.corridor_width, rng);
            }
        }
    }
    
    fn create_ring_network(&self, tiles: &mut Vec<Vec<TileType>>, corridors: &mut Vec<Corridor>,
                         rooms: &Vec<Room>, width: u32, height: u32, params: &MapGenParams, rng: &mut impl Rng) {
        if rooms.len() < 3 { return; }
        
        // Connect rooms in a ring
        for i in 0..rooms.len() {
            let next_i = (i + 1) % rooms.len();
            let room1_center = (rooms[i].x + rooms[i].width / 2, rooms[i].y + rooms[i].height / 2);
            let room2_center = (rooms[next_i].x + rooms[next_i].width / 2, rooms[next_i].y + rooms[next_i].height / 2);
            
            self.create_elaborate_corridor(tiles, corridors, room1_center, room2_center, 
                                         width, height, params.corridor_width, rng);
        }
        
        // Add cross-connections
        for i in 0..rooms.len() {
            let opposite_i = (i + rooms.len() / 2) % rooms.len();
            if rng.random::<f32>() < 0.3 {
                let room1_center = (rooms[i].x + rooms[i].width / 2, rooms[i].y + rooms[i].height / 2);
                let room2_center = (rooms[opposite_i].x + rooms[opposite_i].width / 2, 
                                  rooms[opposite_i].y + rooms[opposite_i].height / 2);
                
                self.create_elaborate_corridor(tiles, corridors, room1_center, room2_center, 
                                             width, height, params.corridor_width, rng);
            }
        }
    }
    
    fn create_elaborate_corridor(&self, tiles: &mut Vec<Vec<TileType>>, corridors: &mut Vec<Corridor>,
                               start: (u32, u32), end: (u32, u32), width: u32, height: u32, 
                               corridor_width: u32, rng: &mut impl Rng) {
        let corridor_style = rng.random_range(0..4);
        
        match corridor_style {
            0 => self.create_straight_corridor(tiles, start, end, width, height, corridor_width),
            1 => self.create_bent_corridor(tiles, start, end, width, height, corridor_width, rng),
            2 => self.create_stepped_corridor(tiles, start, end, width, height, corridor_width, rng),
            _ => self.create_curved_corridor(tiles, start, end, width, height, corridor_width, rng),
        }
        
        corridors.push(Corridor { start, end, width: corridor_width });
    }
    
    fn create_straight_corridor(&self, tiles: &mut Vec<Vec<TileType>>, start: (u32, u32), end: (u32, u32),
                              width: u32, height: u32, corridor_width: u32) {
        let (x1, y1) = start;
        let (x2, y2) = end;
        
        // Bresenham's line algorithm with thickness
        let dx = (x2 as i32 - x1 as i32).abs();
        let dy = (y2 as i32 - y1 as i32).abs();
        let sx = if x1 < x2 { 1 } else { -1 };
        let sy = if y1 < y2 { 1 } else { -1 };
        let mut err = dx - dy;
        let mut x = x1 as i32;
        let mut y = y1 as i32;
        
        loop {
            // Draw thick line
            for offset_x in -(corridor_width as i32 / 2)..=(corridor_width as i32 / 2) {
                for offset_y in -(corridor_width as i32 / 2)..=(corridor_width as i32 / 2) {
                    let px = (x + offset_x) as u32;
                    let py = (y + offset_y) as u32;
                    
                    if px < width && py < height && is_within_ellipse(px, py, width, height) {
                        tiles[py as usize][px as usize] = TileType::Floor;
                    }
                }
            }
            
            if x == x2 as i32 && y == y2 as i32 { break; }
            
            let e2 = 2 * err;
            if e2 > -dy {
                err -= dy;
                x += sx;
            }
            if e2 < dx {
                err += dx;
                y += sy;
            }
        }
    }
    
    fn create_bent_corridor(&self, tiles: &mut Vec<Vec<TileType>>, start: (u32, u32), end: (u32, u32),
                          width: u32, height: u32, corridor_width: u32, rng: &mut impl Rng) {
        // Create an L-shaped corridor with a random bend point
        let (x1, y1) = start;
        let (x2, y2) = end;
        
        let bend_factor = rng.random::<f32>();
        let bend_x = x1 + ((x2 as f32 - x1 as f32) * bend_factor) as u32;
        let bend_y = y1 + ((y2 as f32 - y1 as f32) * (1.0 - bend_factor)) as u32;
        
        // First segment
        self.create_straight_corridor(tiles, start, (bend_x, bend_y), width, height, corridor_width);
        // Second segment
        self.create_straight_corridor(tiles, (bend_x, bend_y), end, width, height, corridor_width);
    }
    
    fn create_stepped_corridor(&self, tiles: &mut Vec<Vec<TileType>>, start: (u32, u32), end: (u32, u32),
                             width: u32, height: u32, corridor_width: u32, rng: &mut impl Rng) {
        // Create corridor with multiple steps/turns
        let (x1, y1) = start;
        let (x2, y2) = end;
        
        let steps = rng.random_range(2..=4);
        let mut current_pos = start;
        
        for i in 0..steps {
            let progress = (i + 1) as f32 / steps as f32;
            let next_x = x1 + ((x2 as f32 - x1 as f32) * progress) as u32;
            let next_y = y1 + ((y2 as f32 - y1 as f32) * progress) as u32;
            
            // Add some randomness to step positions
            let offset_x = rng.random_range(0..3) as i32 - 1;
            let offset_y = rng.random_range(0..3) as i32 - 1;
            
            let step_x = (next_x as i32 + offset_x).max(0).min(width as i32 - 1) as u32;
            let step_y = (next_y as i32 + offset_y).max(0).min(height as i32 - 1) as u32;
            
            self.create_straight_corridor(tiles, current_pos, (step_x, step_y), width, height, corridor_width);
            current_pos = (step_x, step_y);
        }
    }
    
    fn create_curved_corridor(&self, tiles: &mut Vec<Vec<TileType>>, start: (u32, u32), end: (u32, u32),
                            width: u32, height: u32, corridor_width: u32, rng: &mut impl Rng) {
        // Create a curved corridor using bezier-like interpolation
        let (x1, y1) = start;
        let (x2, y2) = end;
        
        // Control point for curve
        let control_x = (x1 + x2) / 2 + rng.random_range(0..10) as u32 - 5;
        let control_y = (y1 + y2) / 2 + rng.random_range(0..10) as u32 - 5;
        
        let steps = 20;
        let mut last_pos = start;
        
        for i in 1..=steps {
            let t = i as f32 / steps as f32;
            let t2 = t * t;
            
            // Quadratic bezier curve
            let x = ((1.0 - t) * (1.0 - t) * x1 as f32 + 
                    2.0 * (1.0 - t) * t * control_x as f32 + 
                    t2 * x2 as f32) as u32;
            let y = ((1.0 - t) * (1.0 - t) * y1 as f32 + 
                    2.0 * (1.0 - t) * t * control_y as f32 + 
                    t2 * y2 as f32) as u32;
            
            let current_pos = (x.min(width - 1), y.min(height - 1));
            self.create_straight_corridor(tiles, last_pos, current_pos, width, height, corridor_width);
            last_pos = current_pos;
        }
    }
    
    fn add_connectivity_loops(&self, tiles: &mut Vec<Vec<TileType>>, rooms: &Vec<Room>, 
                            _corridors: &Vec<Corridor>, width: u32, height: u32, 
                            params: &MapGenParams, rng: &mut impl Rng) {
        // Add additional connections to create loops and prevent isolation
        let connection_attempts = rooms.len() * 2;
        
        for _ in 0..connection_attempts {
            if rng.random::<f32>() < params.connectivity_chance {
                let room1_idx = rng.random_range(0..rooms.len());
                let room2_idx = rng.random_range(0..rooms.len());
                
                if room1_idx != room2_idx {
                    let room1_center = (rooms[room1_idx].x + rooms[room1_idx].width / 2,
                                      rooms[room1_idx].y + rooms[room1_idx].height / 2);
                    let room2_center = (rooms[room2_idx].x + rooms[room2_idx].width / 2,
                                      rooms[room2_idx].y + rooms[room2_idx].height / 2);
                    
                    // Only add if not too close (to avoid redundant connections)
                    let distance = ((room1_center.0 as f32 - room2_center.0 as f32).powi(2) + 
                                  (room1_center.1 as f32 - room2_center.1 as f32).powi(2)).sqrt();
                    
                    if distance > 15.0 {
                        self.create_elaborate_corridor(tiles, &mut Vec::new(), room1_center, room2_center,
                                                     width, height, params.corridor_width, rng);
                    }
                }
            }
        }
    }
    
    fn generate_prison_cells(&self, tiles: &mut Vec<Vec<TileType>>, rooms: &Vec<Room>, 
                           _corridors: &Vec<Corridor>, width: u32, height: u32, 
                           params: &MapGenParams, rng: &mut impl Rng) {
        let cell_attempts = params.max_rooms * 3;
        let mut cells_created = 0;
        
        for _ in 0..cell_attempts {
            if cells_created >= params.max_rooms && rng.random::<f32>() < 0.3 {
                let cell_size = rng.random_range(3..=5);
                let x = rng.random_range(2..width.saturating_sub(cell_size + 2));
                let y = rng.random_range(2..height.saturating_sub(cell_size + 2));
                
                if !is_within_ellipse(x + cell_size / 2, y + cell_size / 2, width, height) {
                    continue;
                }
                
                let cell = Room { x, y, width: cell_size, height: cell_size };
                
                // Check distance from rooms and other structures
                let mut too_close = false;
                for room in rooms {
                    if rooms_overlap(&cell, room, 2) {
                        too_close = true;
                        break;
                    }
                }
                
                if !too_close && self.is_near_corridor(tiles, &cell, width, height) {
                    // Create cell interior
                    for cy in cell.y + 1..cell.y + cell.width - 1 {
                        for cx in cell.x + 1..cell.x + cell.height - 1 {
                            if cx < width && cy < height {
                                tiles[cy as usize][cx as usize] = TileType::Floor;
                            }
                        }
                    }
                    
                    // Create entrance to nearest corridor
                    self.create_cell_entrance(tiles, &cell, width, height);
                    cells_created += 1;
                }
            }
        }
    }
    
    fn is_near_corridor(&self, tiles: &Vec<Vec<TileType>>, cell: &Room, width: u32, height: u32) -> bool {
        // Check if there's a floor tile (corridor) within reasonable distance
        let search_radius = 5;
        
        for dy in -(search_radius as i32)..=(search_radius as i32) {
            for dx in -(search_radius as i32)..=(search_radius as i32) {
                let check_x = (cell.x as i32 + cell.width as i32 / 2 + dx).max(0).min(width as i32 - 1) as usize;
                let check_y = (cell.y as i32 + cell.height as i32 / 2 + dy).max(0).min(height as i32 - 1) as usize;
                
                if tiles[check_y][check_x] == TileType::Floor {
                    return true;
                }
            }
        }
        false
    }
    
    fn create_cell_entrance(&self, tiles: &mut Vec<Vec<TileType>>, cell: &Room, width: u32, height: u32) {
        // Find the best wall position to create an entrance
        let entrance_candidates = vec![
            (cell.x, cell.y + cell.height / 2),     // Left wall
            (cell.x + cell.width - 1, cell.y + cell.height / 2), // Right wall
            (cell.x + cell.width / 2, cell.y),     // Top wall
            (cell.x + cell.width / 2, cell.y + cell.height - 1), // Bottom wall
        ];
        
        for (entrance_x, entrance_y) in entrance_candidates {
            if entrance_x < width && entrance_y < height {
                // Check adjacent positions for existing floor
                let adjacent_positions = vec![
                    (entrance_x.saturating_sub(1), entrance_y),
                    (entrance_x + 1, entrance_y),
                    (entrance_x, entrance_y.saturating_sub(1)),
                    (entrance_x, entrance_y + 1),
                ];
                
                for (adj_x, adj_y) in adjacent_positions {
                    if adj_x < width && adj_y < height {
                        if tiles[adj_y as usize][adj_x as usize] == TileType::Floor {
                            // Create entrance
                            tiles[entrance_y as usize][entrance_x as usize] = TileType::Floor;
                            return;
                        }
                    }
                }
            }
        }
    }
    
    fn eliminate_parallel_walls(&self, tiles: &mut Vec<Vec<TileType>>, width: u32, height: u32, rng: &mut impl Rng) {
        // Identify and fix problematic parallel wall strips
        let mut problem_areas = Vec::new();
        
        // Scan for long parallel wall strips
        for y in 1..height - 1 {
            let mut wall_count = 0;
            let mut wall_start = 0;
            
            for x in 0..width {
                if tiles[y as usize][x as usize] == TileType::Wall {
                    if wall_count == 0 {
                        wall_start = x;
                    }
                    wall_count += 1;
                } else {
                    if wall_count > 8 { // Long wall strip detected
                        // Check if it's a problematic parallel strip
                        if self.is_problematic_wall_strip(tiles, wall_start, y, wall_count, width, height) {
                            problem_areas.push((wall_start, y, wall_count));
                        }
                    }
                    wall_count = 0;
                }
            }
        }
        
        // Fix problem areas by creating openings or widening corridors
        for (start_x, y, length) in problem_areas {
            if rng.random::<f32>() < 0.7 {
                // Create openings in the wall strip
                let openings = rng.random_range(2..=4);
                for i in 0..openings {
                    let opening_x = start_x + (length * i / openings);
                    let opening_width = rng.random_range(1..=3);
                    
                    for ox in opening_x..opening_x + opening_width {
                        if ox < width && is_within_ellipse(ox, y, width, height) {
                            tiles[y as usize][ox as usize] = TileType::Floor;
                            // Also carve above and below to create proper corridors
                            if y > 0 { tiles[(y - 1) as usize][ox as usize] = TileType::Floor; }
                            if y < height - 1 { tiles[(y + 1) as usize][ox as usize] = TileType::Floor; }
                        }
                    }
                }
            }
        }
    }
    
    fn is_problematic_wall_strip(&self, tiles: &Vec<Vec<TileType>>, start_x: u32, y: u32, 
                               length: u32, width: u32, height: u32) -> bool {
        // Check if this wall strip creates isolated parallel corridors
        if y == 0 || y >= height - 1 { return false; }
        
        let above_floors = self.count_adjacent_floors(tiles, start_x, y - 1, length, width);
        let below_floors = self.count_adjacent_floors(tiles, start_x, y + 1, length, width);
        
        // Problematic if there are floor tiles on both sides (creating parallel corridors)
        above_floors > length / 3 && below_floors > length / 3
    }
    
    fn count_adjacent_floors(&self, tiles: &Vec<Vec<TileType>>, start_x: u32, y: u32, 
                           length: u32, width: u32) -> u32 {
        let mut floor_count = 0;
        for x in start_x..start_x + length {
            if x < width && tiles[y as usize][x as usize] == TileType::Floor {
                floor_count += 1;
            }
        }
        floor_count
    }
}

// Helper function for ellipse boundary checking
fn is_within_ellipse(x: u32, y: u32, width: u32, height: u32) -> bool {
    let center_x = width as f32 / 2.0;
    let center_y = height as f32 / 2.0;
    
    let a = (width as f32 / 2.0) - 2.0;
    let b = (height as f32 / 2.0) - 2.0;
    
    let dx = x as f32 - center_x;
    let dy = y as f32 - center_y;
    
    (dx * dx) / (a * a) + (dy * dy) / (b * b) <= 1.0
}

#[derive(Clone)]
struct Room {
    x: u32,
    y: u32,
    width: u32,
    height: u32,
}

#[derive(Clone)]
struct Corridor {
    start: (u32, u32),
    end: (u32, u32),
    width: u32,
}

fn rooms_overlap(room1: &Room, room2: &Room, buffer: u32) -> bool {
    room1.x < room2.x + room2.width + buffer &&
    room1.x + room1.width + buffer > room2.x &&
    room1.y < room2.y + room2.height + buffer &&
    room1.y + room1.height + buffer > room2.y
}

fn create_corridor(tiles: &mut Vec<Vec<TileType>>, room1: &Room, room2: &Room, width: u32, map_width: u32, map_height: u32) {
    let start_x = room1.x + room1.width / 2;
    let start_y = room1.y + room1.height / 2;
    let end_x = room2.x + room2.width / 2;
    let end_y = room2.y + room2.height / 2;
    
    // Create L-shaped corridor
    // First horizontal, then vertical
    let min_x = std::cmp::min(start_x, end_x);
    let max_x = std::cmp::max(start_x, end_x);
    
    // Horizontal segment
    for x in min_x..=max_x {
        for offset in 0..width {
            let y = start_y + offset;
            if x < map_width && y < map_height {
                tiles[y as usize][x as usize] = TileType::Floor;
            }
        }
    }
    
    // Vertical segment
    let min_y = std::cmp::min(start_y, end_y);
    let max_y = std::cmp::max(start_y, end_y);
    
    for y in min_y..=max_y {
        for offset in 0..width {
            let x = end_x + offset;
            if x < map_width && y < map_height {
                tiles[y as usize][x as usize] = TileType::Floor;
            }
        }
    }
}

pub fn get_generator(algorithm: &MapGenAlgorithm) -> Box<dyn MapGenerator> {
    match algorithm {
        MapGenAlgorithm::DrunkardWalk => Box::new(DrunkardWalkGenerator),
        MapGenAlgorithm::PrisonBlocks => Box::new(PrisonBlocksGenerator),
        MapGenAlgorithm::BSPDungeon => Box::new(BSPDungeonGenerator),
        MapGenAlgorithm::Voronoi => Box::new(VoronoiGenerator),
        // TODO: Implement other generators
        _ => Box::new(DrunkardWalkGenerator), // Fallback to drunkard walk
    }
}

pub struct BSPDungeonGenerator;

impl MapGenerator for BSPDungeonGenerator {
    fn generate(&mut self, width: u32, height: u32, params: &MapGenParams) -> Vec<TileType> {
        let mut tiles = vec![vec![TileType::Wall; width as usize]; height as usize];
        let mut rng = rand::rng();
        let mut rooms = Vec::new();
        
        // Create the initial partition covering most of the elliptical area
        let margin = 8;
        let initial_partition = BSPNode {
            x: margin,
            y: margin,
            width: width.saturating_sub(margin * 2),
            height: height.saturating_sub(margin * 2),
            left: None,
            right: None,
            room: None,
        };
        
        // Build BSP tree with recursive subdivision
        let mut root = Box::new(initial_partition);
        self.subdivide(&mut root, params, &mut rng, 0);
        
        // Generate rooms in leaf nodes
        self.create_rooms(&mut root, &mut tiles, &mut rooms, width, height, params, &mut rng);
        
        // Connect rooms with corridors
        self.connect_rooms(&mut tiles, &rooms, width, height, params, &mut rng);
        
        // Add fortress-style features for prison theme
        self.add_fortress_features(&mut tiles, &rooms, width, height, params, &mut rng);
        
        tiles
    }
}

impl BSPDungeonGenerator {
    fn subdivide(&self, node: &mut Box<BSPNode>, params: &MapGenParams, rng: &mut impl Rng, depth: u32) {
        // Stop subdivision if area is too small or max depth reached
        let max_depth = 4;
        let min_size = params.room_min_size * 2 + 3; // Minimum size to fit room + walls + corridor
        
        if depth >= max_depth || (node.width < min_size * 2 || node.height < min_size * 2) {
            return;
        }
        
        // Decide whether to split horizontally or vertically
        let split_horizontally = if node.width > node.height * 2 {
            false // Split vertically if too wide
        } else if node.height > node.width * 2 {
            true // Split horizontally if too tall
        } else {
            rng.random::<bool>() // Random choice if reasonably proportioned
        };
        
        if split_horizontally {
            // Split horizontally
            let min_height = min_size;
            let max_split = node.height.saturating_sub(min_height);
            if max_split < min_height { return; }
            
            let split_pos = rng.random_range(min_height..max_split);
            
            node.left = Some(Box::new(BSPNode {
                x: node.x,
                y: node.y,
                width: node.width,
                height: split_pos,
                left: None,
                right: None,
                room: None,
            }));
            
            node.right = Some(Box::new(BSPNode {
                x: node.x,
                y: node.y + split_pos,
                width: node.width,
                height: node.height - split_pos,
                left: None,
                right: None,
                room: None,
            }));
        } else {
            // Split vertically
            let min_width = min_size;
            let max_split = node.width.saturating_sub(min_width);
            if max_split < min_width { return; }
            
            let split_pos = rng.random_range(min_width..max_split);
            
            node.left = Some(Box::new(BSPNode {
                x: node.x,
                y: node.y,
                width: split_pos,
                height: node.height,
                left: None,
                right: None,
                room: None,
            }));
            
            node.right = Some(Box::new(BSPNode {
                x: node.x + split_pos,
                y: node.y,
                width: node.width - split_pos,
                height: node.height,
                left: None,
                right: None,
                room: None,
            }));
        }
        
        // Recursively subdivide children
        if let Some(ref mut left) = node.left {
            self.subdivide(left, params, rng, depth + 1);
        }
        if let Some(ref mut right) = node.right {
            self.subdivide(right, params, rng, depth + 1);
        }
    }
    
    fn create_rooms(&self, node: &mut Box<BSPNode>, tiles: &mut Vec<Vec<TileType>>, 
                   rooms: &mut Vec<Room>, width: u32, height: u32, 
                   params: &MapGenParams, rng: &mut impl Rng) {
        // If this is a leaf node, create a room
        if node.left.is_none() && node.right.is_none() {
            let margin = 2;
            let max_room_width = node.width.saturating_sub(margin * 2).min(params.room_max_size);
            let max_room_height = node.height.saturating_sub(margin * 2).min(params.room_max_size);
            let min_room_width = params.room_min_size.min(max_room_width);
            let min_room_height = params.room_min_size.min(max_room_height);
            
            if max_room_width >= min_room_width && max_room_height >= min_room_height {
                let room_width = rng.random_range(min_room_width..=max_room_width);
                let room_height = rng.random_range(min_room_height..=max_room_height);
                
                let max_x_offset = node.width.saturating_sub(room_width);
                let max_y_offset = node.height.saturating_sub(room_height);
                
                let room_x = node.x + rng.random_range(0..=max_x_offset);
                let room_y = node.y + rng.random_range(0..=max_y_offset);
                
                // Only create room if within ellipse boundary
                let center_x = room_x + room_width / 2;
                let center_y = room_y + room_height / 2;
                
                if is_within_ellipse(center_x, center_y, width, height) {
                    let room = Room { x: room_x, y: room_y, width: room_width, height: room_height };
                    
                    // Carve room with fortress-style walls
                    self.carve_fortress_room(tiles, &room, width, height, rng);
                    
                    node.room = Some(room.clone());
                    rooms.push(room);
                }
            }
        } else {
            // Recursively create rooms in children
            if let Some(ref mut left) = node.left {
                self.create_rooms(left, tiles, rooms, width, height, params, rng);
            }
            if let Some(ref mut right) = node.right {
                self.create_rooms(right, tiles, rooms, width, height, params, rng);
            }
        }
    }
    
    fn carve_fortress_room(&self, tiles: &mut Vec<Vec<TileType>>, room: &Room, 
                          width: u32, height: u32, rng: &mut impl Rng) {
        let room_style = rng.random_range(0..4);
        
        match room_style {
            0 => {
                // Standard rectangular room
                for y in room.y..room.y + room.height {
                    for x in room.x..room.x + room.width {
                        if x < width && y < height {
                            tiles[y as usize][x as usize] = TileType::Floor;
                        }
                    }
                }
            },
            1 => {
                // Room with internal pillars (fortress-style)
                for y in room.y..room.y + room.height {
                    for x in room.x..room.x + room.width {
                        if x < width && y < height {
                            tiles[y as usize][x as usize] = TileType::Floor;
                        }
                    }
                }
                
                // Add internal pillars for large rooms
                if room.width > 8 && room.height > 8 {
                    let pillar_x = room.x + room.width / 2;
                    let pillar_y = room.y + room.height / 2;
                    if pillar_x < width && pillar_y < height {
                        tiles[pillar_y as usize][pillar_x as usize] = TileType::Wall;
                    }
                }
            },
            2 => {
                // L-shaped room (common in fortress layouts)
                let split_x = room.x + room.width * 2 / 3;
                let split_y = room.y + room.height * 2 / 3;
                
                // Main rectangle
                for y in room.y..split_y {
                    for x in room.x..room.x + room.width {
                        if x < width && y < height {
                            tiles[y as usize][x as usize] = TileType::Floor;
                        }
                    }
                }
                
                // Extension rectangle
                for y in split_y..room.y + room.height {
                    for x in room.x..split_x {
                        if x < width && y < height {
                            tiles[y as usize][x as usize] = TileType::Floor;
                        }
                    }
                }
            },
            _ => {
                // Room with alcoves (prison cell style)
                // Main room
                for y in room.y + 1..room.y + room.height - 1 {
                    for x in room.x + 1..room.x + room.width - 1 {
                        if x < width && y < height {
                            tiles[y as usize][x as usize] = TileType::Floor;
                        }
                    }
                }
                
                // Add small alcoves along walls
                if room.width > 6 {
                    let alcove_x = room.x + room.width - 1;
                    let alcove_y = room.y + room.height / 2;
                    if alcove_x < width && alcove_y < height {
                        tiles[alcove_y as usize][alcove_x as usize] = TileType::Floor;
                    }
                }
            }
        }
    }
    
    fn connect_rooms(&self, tiles: &mut Vec<Vec<TileType>>, rooms: &Vec<Room>, 
                    width: u32, height: u32, params: &MapGenParams, rng: &mut impl Rng) {
        if rooms.len() < 2 { return; }
        
        // Create a minimum spanning tree of connections
        let mut connected = vec![false; rooms.len()];
        connected[0] = true;
        let mut num_connected = 1;
        
        while num_connected < rooms.len() {
            let mut min_distance = f32::INFINITY;
            let mut best_connection = (0, 0);
            
            // Find closest unconnected room to any connected room
            for i in 0..rooms.len() {
                if connected[i] {
                    for j in 0..rooms.len() {
                        if !connected[j] {
                            let room1_center = (rooms[i].x + rooms[i].width / 2, rooms[i].y + rooms[i].height / 2);
                            let room2_center = (rooms[j].x + rooms[j].width / 2, rooms[j].y + rooms[j].height / 2);
                            
                            let distance = ((room1_center.0 as f32 - room2_center.0 as f32).powi(2) + 
                                          (room1_center.1 as f32 - room2_center.1 as f32).powi(2)).sqrt();
                            
                            if distance < min_distance {
                                min_distance = distance;
                                best_connection = (i, j);
                            }
                        }
                    }
                }
            }
            
            // Connect the closest rooms
            let (from_idx, to_idx) = best_connection;
            self.create_fortress_corridor(tiles, &rooms[from_idx], &rooms[to_idx], width, height, params.corridor_width, rng);
            connected[to_idx] = true;
            num_connected += 1;
        }
        
        // Add some additional connections for loops (fortress complexity)
        let extra_connections = (rooms.len() / 3).max(1);
        for _ in 0..extra_connections {
            if rng.random::<f32>() < params.connectivity_chance {
                let room1_idx = rng.random_range(0..rooms.len());
                let room2_idx = rng.random_range(0..rooms.len());
                
                if room1_idx != room2_idx {
                    self.create_fortress_corridor(tiles, &rooms[room1_idx], &rooms[room2_idx], 
                                                width, height, params.corridor_width, rng);
                }
            }
        }
    }
    
    fn create_fortress_corridor(&self, tiles: &mut Vec<Vec<TileType>>, room1: &Room, room2: &Room,
                               width: u32, height: u32, corridor_width: u32, rng: &mut impl Rng) {
        let start_x = room1.x + room1.width / 2;
        let start_y = room1.y + room1.height / 2;
        let end_x = room2.x + room2.width / 2;
        let end_y = room2.y + room2.height / 2;
        
        // Create fortress-style corridors (structured, not random)
        if rng.random::<bool>() {
            // Horizontal first, then vertical
            self.carve_corridor_segment(tiles, start_x, start_y, end_x, start_y, width, height, corridor_width);
            self.carve_corridor_segment(tiles, end_x, start_y, end_x, end_y, width, height, corridor_width);
        } else {
            // Vertical first, then horizontal
            self.carve_corridor_segment(tiles, start_x, start_y, start_x, end_y, width, height, corridor_width);
            self.carve_corridor_segment(tiles, start_x, end_y, end_x, end_y, width, height, corridor_width);
        }
    }
    
    fn carve_corridor_segment(&self, tiles: &mut Vec<Vec<TileType>>, x1: u32, y1: u32, x2: u32, y2: u32,
                             width: u32, height: u32, corridor_width: u32) {
        let min_x = x1.min(x2);
        let max_x = x1.max(x2);
        let min_y = y1.min(y2);
        let max_y = y1.max(y2);
        
        for y in min_y..=max_y {
            for x in min_x..=max_x {
                // Apply corridor width
                for offset_x in 0..corridor_width {
                    for offset_y in 0..corridor_width {
                        let cx = x + offset_x;
                        let cy = y + offset_y;
                        
                        if cx < width && cy < height && is_within_ellipse(cx, cy, width, height) {
                            tiles[cy as usize][cx as usize] = TileType::Floor;
                        }
                    }
                }
            }
        }
    }
    
    fn add_fortress_features(&self, tiles: &mut Vec<Vec<TileType>>, rooms: &Vec<Room>, 
                           width: u32, height: u32, _params: &MapGenParams, rng: &mut impl Rng) {
        // Add small guard posts or prison cells along corridors
        self.add_guard_posts(tiles, rooms, width, height, rng);
        
        // Add some fortress-style structural elements
        self.add_structural_walls(tiles, width, height, rng);
    }
    
    fn add_guard_posts(&self, tiles: &mut Vec<Vec<TileType>>, rooms: &Vec<Room>, 
                      width: u32, height: u32, rng: &mut impl Rng) {
        let post_attempts = rooms.len() * 2;
        
        for _ in 0..post_attempts {
            if rng.random::<f32>() < 0.3 {
                let post_size = 3;
                let x = rng.random_range(3..width.saturating_sub(post_size + 3));
                let y = rng.random_range(3..height.saturating_sub(post_size + 3));
                
                if !is_within_ellipse(x + post_size / 2, y + post_size / 2, width, height) {
                    continue;
                }
                
                // Check if area is mostly walls (good spot for a guard post)
                let mut wall_count = 0;
                let check_radius = 2;
                for dy in -(check_radius as i32)..=(check_radius as i32) {
                    for dx in -(check_radius as i32)..=(check_radius as i32) {
                        let check_x = (x as i32 + dx).max(0).min(width as i32 - 1) as usize;
                        let check_y = (y as i32 + dy).max(0).min(height as i32 - 1) as usize;
                        
                        if tiles[check_y][check_x] == TileType::Wall {
                            wall_count += 1;
                        }
                    }
                }
                
                // If mostly surrounded by walls, check for nearby corridor
                if wall_count > 15 && self.is_near_corridor_bsp(tiles, x, y, width, height) {
                    // Create small guard post
                    for py in y..y + post_size {
                        for px in x..x + post_size {
                            if px < width && py < height {
                                tiles[py as usize][px as usize] = TileType::Floor;
                            }
                        }
                    }
                    
                    // Connect to nearest corridor
                    self.connect_to_corridor(tiles, x + post_size / 2, y + post_size / 2, width, height);
                }
            }
        }
    }
    
    fn is_near_corridor_bsp(&self, tiles: &Vec<Vec<TileType>>, x: u32, y: u32, width: u32, height: u32) -> bool {
        let search_radius = 4;
        
        for dy in -(search_radius as i32)..=(search_radius as i32) {
            for dx in -(search_radius as i32)..=(search_radius as i32) {
                let check_x = (x as i32 + dx).max(0).min(width as i32 - 1) as usize;
                let check_y = (y as i32 + dy).max(0).min(height as i32 - 1) as usize;
                
                if tiles[check_y][check_x] == TileType::Floor {
                    return true;
                }
            }
        }
        false
    }
    
    fn connect_to_corridor(&self, tiles: &mut Vec<Vec<TileType>>, start_x: u32, start_y: u32, 
                          width: u32, height: u32) {
        // Find nearest floor tile and create connection
        let mut min_distance = f32::INFINITY;
        let mut target = (start_x, start_y);
        
        let search_radius = 8;
        for dy in -(search_radius as i32)..=(search_radius as i32) {
            for dx in -(search_radius as i32)..=(search_radius as i32) {
                let check_x = (start_x as i32 + dx).max(0).min(width as i32 - 1) as u32;
                let check_y = (start_y as i32 + dy).max(0).min(height as i32 - 1) as u32;
                
                if tiles[check_y as usize][check_x as usize] == TileType::Floor {
                    let distance = ((dx * dx + dy * dy) as f32).sqrt();
                    if distance < min_distance {
                        min_distance = distance;
                        target = (check_x, check_y);
                    }
                }
            }
        }
        
        // Create connection
        if target != (start_x, start_y) {
            self.carve_corridor_segment(tiles, start_x, start_y, target.0, target.1, width, height, 1);
        }
    }
    
    fn add_structural_walls(&self, tiles: &mut Vec<Vec<TileType>>, width: u32, height: u32, rng: &mut impl Rng) {
        // Add some fortress-style internal walls or barriers
        let wall_attempts = 3;
        
        for _ in 0..wall_attempts {
            if rng.random::<f32>() < 0.4 {
                let wall_length = rng.random_range(5..12);
                let is_horizontal = rng.random::<bool>();
                
                if is_horizontal {
                    let start_x = rng.random_range(5..width.saturating_sub(wall_length + 5));
                    let wall_y = rng.random_range(5..height - 5);
                    
                    if is_within_ellipse(start_x + wall_length / 2, wall_y, width, height) {
                        let mut can_place = true;
                        
                        // Check if wall would block essential paths
                        for x in start_x..start_x + wall_length {
                            if x < width && tiles[wall_y as usize][x as usize] == TileType::Floor {
                                can_place = false;
                                break;
                            }
                        }
                        
                        if can_place {
                            for x in start_x..start_x + wall_length {
                                if x < width {
                                    tiles[wall_y as usize][x as usize] = TileType::Wall;
                                }
                            }
                        }
                    }
                } else {
                    let wall_x = rng.random_range(5..width - 5);
                    let start_y = rng.random_range(5..height.saturating_sub(wall_length + 5));
                    
                    if is_within_ellipse(wall_x, start_y + wall_length / 2, width, height) {
                        let mut can_place = true;
                        
                        // Check if wall would block essential paths
                        for y in start_y..start_y + wall_length {
                            if y < height && tiles[y as usize][wall_x as usize] == TileType::Floor {
                                can_place = false;
                                break;
                            }
                        }
                        
                        if can_place {
                            for y in start_y..start_y + wall_length {
                                if y < height {
                                    tiles[y as usize][wall_x as usize] = TileType::Wall;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

#[derive(Clone)]
struct BSPNode {
    x: u32,
    y: u32,
    width: u32,
    height: u32,
    left: Option<Box<BSPNode>>,
    right: Option<Box<BSPNode>>,
    room: Option<Room>,
}

pub struct VoronoiGenerator;

impl MapGenerator for VoronoiGenerator {
    fn generate(&mut self, width: u32, height: u32, params: &MapGenParams) -> Vec<TileType> {
        let mut tiles = vec![vec![TileType::Wall; width as usize]; height as usize]; // Start with walls (trees)
        let mut rng = rand::rng();
        
        // Generate Voronoi sites for forest clearings
        let num_sites = params.walkers; // Use walkers as number of Voronoi sites
        let mut sites = Vec::new();
        
        // Generate random Voronoi sites within ellipse boundary
        for _ in 0..num_sites {
            let mut attempts = 0;
            loop {
                let x = rng.random_range(1..width-1);
                let y = rng.random_range(1..height-1);
                if is_within_ellipse(x, y, width, height) {
                    sites.push((x, y));
                    break;
                }
                attempts += 1;
                if attempts > 100 {
                    // Fallback to center area if can't find good position
                    sites.push((width / 2, height / 2));
                    break;
                }
            }
        }
        
        // Create clearings around each Voronoi site
        for &(site_x, site_y) in &sites {
            let clearing_size = rng.random_range(params.room_min_size..=params.room_max_size);
            self.create_clearing(&mut tiles, site_x, site_y, clearing_size, width, height);
        }
        
        // Generate noise-based tree density for more natural forest areas
        self.add_tree_clusters(&mut tiles, width, height, &mut rng);
        
        // Create winding paths between clearings using drunkard's walk
        self.create_forest_paths(&mut tiles, &sites, params.corridor_width, params.connectivity_chance, width, height, &mut rng);
        
        // Add scattered individual clearings in dense areas
        self.add_individual_clearings(&mut tiles, width, height, &mut rng);
        
        tiles
    }
}

impl VoronoiGenerator {
    fn create_clearing(&self, tiles: &mut Vec<Vec<TileType>>, center_x: u32, center_y: u32, size: u32, width: u32, height: u32) {
        let radius = size / 2;
        
        for dy in -(radius as i32)..=radius as i32 {
            for dx in -(radius as i32)..=radius as i32 {
                let x = center_x as i32 + dx;
                let y = center_y as i32 + dy;
                
                if x >= 0 && x < width as i32 && y >= 0 && y < height as i32 {
                    let distance = ((dx * dx + dy * dy) as f32).sqrt();
                    if distance <= radius as f32 && is_within_ellipse(x as u32, y as u32, width, height) {
                        tiles[y as usize][x as usize] = TileType::Floor;
                    }
                }
            }
        }
    }
    
    fn add_tree_clusters(&self, tiles: &mut Vec<Vec<TileType>>, width: u32, height: u32, rng: &mut impl Rng) {
        // Create noise-like patterns for tree density
        for y in 0..height {
            for x in 0..width {
                if !is_within_ellipse(x, y, width, height) {
                    continue;
                }
                
                // Use simple noise approximation based on position
                let noise_value = ((x * 73 + y * 149) % 100) as f32 / 100.0;
                let cluster_threshold = 0.3; // 30% chance for dense tree clusters
                
                if noise_value < cluster_threshold && tiles[y as usize][x as usize] == TileType::Wall {
                    // This area gets denser trees (keep as walls)
                    continue;
                } else if noise_value > 0.7 && rng.random::<f32>() < 0.4 {
                    // 40% chance to create small clearings in less dense areas
                    if tiles[y as usize][x as usize] == TileType::Wall {
                        tiles[y as usize][x as usize] = TileType::Floor;
                    }
                }
            }
        }
    }
    
    fn create_forest_paths(&self, tiles: &mut Vec<Vec<TileType>>, sites: &[(u32, u32)], path_width: u32, connectivity: f32, width: u32, height: u32, rng: &mut impl Rng) {
        // Connect clearings with winding paths using modified drunkard's walk
        for i in 0..sites.len() {
            for j in i+1..sites.len() {
                if rng.random::<f32>() < connectivity {
                    self.create_winding_path(tiles, sites[i], sites[j], path_width, width, height, rng);
                }
            }
        }
        
        // Ensure all clearings are connected by creating a minimum spanning tree
        if sites.len() > 1 {
            let mut connected = vec![false; sites.len()];
            connected[0] = true;
            
            for _ in 1..sites.len() {
                let mut min_dist = f32::INFINITY;
                let mut best_pair = (0, 0);
                
                for i in 0..sites.len() {
                    if !connected[i] {
                        continue;
                    }
                    for j in 0..sites.len() {
                        if connected[j] {
                            continue;
                        }
                        let dist = self.distance(sites[i], sites[j]);
                        if dist < min_dist {
                            min_dist = dist;
                            best_pair = (i, j);
                        }
                    }
                }
                
                connected[best_pair.1] = true;
                self.create_winding_path(tiles, sites[best_pair.0], sites[best_pair.1], path_width, width, height, rng);
            }
        }
    }
    
    fn create_winding_path(&self, tiles: &mut Vec<Vec<TileType>>, start: (u32, u32), end: (u32, u32), width: u32, map_width: u32, map_height: u32, rng: &mut impl Rng) {
        let mut current_x = start.0 as i32;
        let mut current_y = start.1 as i32;
        let target_x = end.0 as i32;
        let target_y = end.1 as i32;
        
        while current_x != target_x || current_y != target_y {
            // Carve path at current position
            self.carve_path_section(tiles, current_x, current_y, width, map_width, map_height);
            
            // Move toward target with some randomness for winding effect
            let dx = if current_x < target_x { 1 } else if current_x > target_x { -1 } else { 0 };
            let dy = if current_y < target_y { 1 } else if current_y > target_y { -1 } else { 0 };
            
            // Add randomness to create winding paths
            if rng.random::<f32>() < 0.3 {
                // 30% chance to take a random step for winding effect
                let random_dir = rng.random_range(0..4);
                match random_dir {
                    0 => current_y -= 1,
                    1 => current_x += 1,
                    2 => current_y += 1,
                    3 => current_x -= 1,
                    _ => {}
                }
            } else {
                // Move toward target
                current_x += dx;
                current_y += dy;
            }
            
            // Bounds checking
            current_x = current_x.max(0).min((map_width - 1) as i32);
            current_y = current_y.max(0).min((map_height - 1) as i32);
        }
        
        // Final carve at destination
        self.carve_path_section(tiles, current_x, current_y, width, map_width, map_height);
    }
    
    fn carve_path_section(&self, tiles: &mut Vec<Vec<TileType>>, center_x: i32, center_y: i32, width: u32, map_width: u32, map_height: u32) {
        let radius = width as i32 / 2;
        
        for dy in -radius..=radius {
            for dx in -radius..=radius {
                let x = center_x + dx;
                let y = center_y + dy;
                
                if x >= 0 && x < map_width as i32 && y >= 0 && y < map_height as i32 {
                    if is_within_ellipse(x as u32, y as u32, map_width, map_height) {
                        tiles[y as usize][x as usize] = TileType::Floor;
                    }
                }
            }
        }
    }
    
    fn add_individual_clearings(&self, tiles: &mut Vec<Vec<TileType>>, width: u32, height: u32, rng: &mut impl Rng) {
        // Add small random clearings scattered throughout the forest
        let num_clearings = (width * height) / 400; // Roughly 1 per 20x20 area
        
        for _ in 0..num_clearings {
            let x = rng.random_range(2..width-2);
            let y = rng.random_range(2..height-2);
            
            if is_within_ellipse(x, y, width, height) && tiles[y as usize][x as usize] == TileType::Wall {
                // Small 1-2 tile clearings
                let clearing_size = rng.random_range(1..=2);
                for dy in 0..clearing_size {
                    for dx in 0..clearing_size {
                        let nx = x + dx;
                        let ny = y + dy;
                        if nx < width && ny < height && is_within_ellipse(nx, ny, width, height) {
                            tiles[ny as usize][nx as usize] = TileType::Floor;
                        }
                    }
                }
            }
        }
    }
    
    fn distance(&self, p1: (u32, u32), p2: (u32, u32)) -> f32 {
        let dx = p1.0 as f32 - p2.0 as f32;
        let dy = p1.1 as f32 - p2.1 as f32;
        (dx * dx + dy * dy).sqrt()
    }
}
